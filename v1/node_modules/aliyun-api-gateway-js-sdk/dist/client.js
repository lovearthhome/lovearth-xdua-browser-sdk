"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const base_1 = __importDefault(require("./base"));
const headers_1 = require("./util/headers");
const contentTypes_1 = require("./constants/contentTypes");
const myCrypto_1 = require("./util/myCrypto");
const sign_1 = require("./util/sign");
const encodeData_1 = require("./util/encodeData");
const sort_1 = require("./util/sort");
class Client extends base_1.default {
    constructor(key, secret, stage = 'RELEASE') {
        super();
        this.appKey = key;
        this.appSecret = secret;
        this.stage = stage;
    }
    request(method, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const signHeaders = opts.signHeaders;
            const headers = headers_1.buildHeaders(opts.headers, signHeaders, this.appKey, this.stage);
            delete headers['accept'];
            const requestContentType = headers['content-type'] || '';
            if (method === 'POST' || method === 'PUT') {
                if (!requestContentType.startsWith(contentTypes_1.CONTENT_TYPE_FORM)) {
                    let stringifyData = JSON.stringify(opts.data);
                    headers['content-md5'] = myCrypto_1.myMd5(stringifyData);
                }
                else {
                    opts.data = sort_1.sortKey(opts.data);
                }
            }
            const signHeaderKeys = headers_1.getSignHeaderKeys(headers, signHeaders);
            headers['x-ca-signature-headers'] = signHeaderKeys.join(',');
            const signedHeadersStr = headers_1.getSignedHeadersString(signHeaderKeys, headers);
            const stringToSign = sign_1.buildStringToSign(method, headers, signedHeadersStr, opts.url, opts.data, opts.params);
            headers['x-ca-signature'] = myCrypto_1.myHmacsha256(stringToSign, this.appSecret);
            if (method === 'POST' || method === 'PUT') {
                if (requestContentType.startsWith(contentTypes_1.CONTENT_TYPE_FORM)) {
                    opts.data = encodeData_1.encodeData(opts.data);
                }
            }
            let config = {
                method,
                url: opts.url,
                headers,
                data: opts.data,
                params: opts.params,
                timeout: opts.timeout || 5000,
            };
            return axios_1.default(config);
        });
    }
}
exports.Client = Client;
//# sourceMappingURL=client.js.map
